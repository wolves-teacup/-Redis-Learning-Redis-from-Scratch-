# 从零起步学习Redis || 第四章:Cache Aside Pattern(旁路缓存模式)以及优化策略
## 前言
今天继续我们的Redis学习，主要讲解一下Cache Aside Pattern（旁路缓存模式）

## 概念
Cache Aside Pattern，又称 Lazy Loading（懒加载）模式，是一种典型的**应用程序主动去操作缓存**的策略。
核心思想是：应用程序先从缓存中读取数据，如果缓存中没有，再去数据库加载，并把数据写入缓存。
换句话说，缓存是“旁路”式的，数据的来源仍然是数据库，缓存只是辅助，应用程序负责管理缓存。

## 工作原理
### 读取数据流程
1. 应用程序尝试从缓存中读取数据。
2. 如果缓存命中（cache hit），直接返回数据。
3. 如果缓存未命中（cache miss）：
    - 从数据库中读取数据。
    - 将数据写入缓存（可设置 TTL，防止缓存永久存在）。
    - 返回数据给客户端。

### 写入数据流程
1. 当数据更新时，先更新数据库。
2. 再删除缓存中对应的数据（或直接更新缓存）。
3. 下次读取时，会重新加载最新数据到缓存。

**关键点**：应用程序负责控制缓存和数据库的数据一致性。

## 重点问题：为什么要先操作数据库，再操作缓存？
### 场景设定
高并发下的数据更新，数据 X 初始值 `X=10`（保存在数据库和缓存中）：
- 请求 A（写请求）：要将 `X` 更新为 `20`。
- 请求 B（读请求）：在 A 的更新操作过程中读取 `X`。
- 目标状态：数据库 `X=20`，缓存 `X=20`（或缓存无 X，下次读时回填）。

### 错误顺序剖析：先删缓存，再更新数据库（`删除Cache -> 更新DB`）
#### 执行流程
| 步骤 | 操作主体 | 操作内容 | 结果 |
|------|----------|----------|------|
| 1 | 请求 A（写） | 删除缓存中的 X | 缓存为空 |
| 2 | 请求 A（写） | 开始更新数据库 X=20（较慢操作） | 数据库更新中 |
| 3 | 请求 B（读） | 读取缓存中的 X | 未命中（Not Found） |
| 4 | 请求 B（读） | 读取数据库中的 X | 拿到旧值 X=10（A 的更新未完成） |
| 5 | 请求 B（读） | 将 X=10 写入缓存 | 缓存中存入旧值 |
| 6 | 请求 A（写） | 完成数据库更新 | 数据库 X=20（新值） |

#### 最终状态
- 数据库：`X=20`（新值）
- 缓存：`X=10`（旧值）
- 严重后果：脏数据长期驻留缓存，后续所有读请求都会拿到错误的旧值，直到缓存过期或下次写操作删除缓存。

#### 关键问题解读
- 数据库更新操作相对较慢（涉及网络 I/O、磁盘 I/O、事务处理等），在更新完成前，读请求会从数据库读取旧值并回填缓存。
- 一旦旧值被写入缓存，会长期存在，导致缓存与数据库数据不一致。

### 正确顺序剖析：先更新数据库，再删除缓存（`更新DB -> 删除Cache`）
#### 执行流程
| 步骤 | 操作主体 | 操作内容 | 结果 |
|------|----------|----------|------|
| 1 | 请求 A（写） | 开始更新数据库 X=20（较慢操作） | 数据库更新中 |
| 2 | 请求 B（读） | 读取缓存中的 X | 命中旧值 X=10（短暂不一致） |
| 3 | 请求 A（写） | 完成数据库更新 | 数据库 X=20（新值） |
| 4 | 请求 A（写） | 删除缓存中的 X | 缓存为空 |

#### 特殊情况补充（B 在不同阶段读取）
1. **情况 1**：B 在 A 删缓存前未读 → 缓存被 A 删除后为空，下次读触发回填新值。
2. **情况 2**：B 在 A 删缓存前读了旧值 → 缓存中的旧值随后被 A 删除，下次读触发回填新值。
3. **情况 3**：B 在 A 更新 DB 完成后、删缓存前读（罕见）：
    - B 读缓存未命中（或已过期）。
    - B 读数据库，拿到新值 X=20。
    - B 将新值 X=20 写入缓存。
    - A 执行删除缓存操作，删除 B 刚写入的新值。
    - 最终缓存为空，下次读触发回填新值。

#### 最终状态 & 自我修复
- 数据库：`X=20`（确定新值）。
- 缓存：X 被删除（为空）。
- 后续读请求流程：
    1. 读缓存未命中 → 读数据库拿到新值 20 → 回填缓存。
    2. 系统达成最终一致：数据库和缓存均为 X=20。
- 核心优势：短暂的不一致（B 读到旧值）会被后续读流程自动修复，不会出现脏数据长期驻留的情况。

### 两种顺序对比表
| 特性 | 错误顺序：`删缓存 -> 更新DB` | 正确顺序：`更新DB -> 删缓存` | 优势说明 |
|------|------------------------------|------------------------------|----------|
| 脏数据驻留缓存风险 | 极高 | 极低 | 错误顺序导致旧数据被读请求回填并长期留存；正确顺序通过后续删除和读回填确保缓存最终是新数据或空。 |
| 不一致持续时间 | 长 (直到下次写/缓存过期) | 短 (通常毫秒级，直到下次读请求回填) | 正确顺序下不一致窗口仅限于并发读写重叠且读在 DB 更新后、缓存删除前的极短时间 + 下次读请求的处理时间。 |
| 操作失败后果 | 严重 (删缓存成功+更新DB失败：缓存空+DB旧值) | 相对可控 (更新DB成功+删缓存失败：DB新值+缓存旧值) | DB 有正确的新值是底线。缓存旧值可通过重试删除、TTL 过期或下次触发删除修复。缓存空+DB 旧值会导致数据丢失错觉。 |
| 设计理念符合度 | 低 (直接干预缓存作为写入口) | 高 (缓存是副本，写只操作数据源 DB，失效缓存副本) | 逻辑更清晰，职责分离。 |
| 并发写影响 | 可能导致缓存与 DB 都错乱 | 无额外影响 | 正确顺序只涉及 DB 并发写（DB 自身事务保证）和独立的缓存删除。 |

## 优化方案：解决缓存中仍有旧数据的问题
### 1. 双删（Double Delete）
- **做法**：事务提交后删一次缓存，稍微 `sleep` 几十毫秒，再删一次。
- **作用**：避免并发线程把旧值写回缓存。
- **缺点**：依赖 `sleep`，效果不稳定，属于“土办法”。

### 2. 更新缓存（而不是删除）
- **做法**：在 DB 提交成功后，直接 `set(key, newValue)`。
- **优点**：减少旧值回写缓存的机会。
- **缺点**：需要处理并发写入的覆盖问题（可能要用版本号/CAS 机制）。

### 3. 版本号 / 时间戳机制
- **做法**：缓存中存储一个 `version` 字段，每次更新时带上版本号；写缓存时只在 `newVersion > oldVersion` 时才覆盖。
- **优点**：能有效防止旧值覆盖新值。
- **缺点**：实现复杂度稍高。

### 4. 分布式锁（针对热点 Key）
- **做法**：在回填缓存时对 Key 加分布式锁（如 Redis 的 `SETNX`）。
- **作用**：确保同一时刻只有一个线程能写入缓存，避免并发覆盖。
- **缺点**：增加延迟，适合少量热点 Key，不适合全局使用。

### 5. 事件驱动（消息队列同步）
- **做法**：DB 更新成功后，发消息到 MQ，各个服务节点订阅并失效本地缓存。
- **优点**：在分布式场景下保持多实例缓存一致性。
- **缺点**：引入 MQ，系统架构更复杂。

## 总结
### 基本原则
先写数据库，再操作缓存（删除或更新），因为数据库是权威数据源。这样可以避免缓存中长期存在脏数据。

### 仍然可能的问题
在高并发下，缓存中仍可能被旧数据覆盖（短暂不一致）。

### 常见优化手段
1. 双删（double delete）：DB 提交后删一次缓存，再延迟一小段时间再删一次。
2. 更新缓存而不是删除：直接把新值写入缓存，减少 cache miss。
3. 版本号 / 时间戳：缓存数据携带版本，只有新版本才能覆盖旧版本。
4. 分布式锁：对热点 key 加锁，避免多个线程同时写缓存。
5. 事件驱动（消息队列）：DB 更新后发事件，多个服务节点订阅，统一删除/更新缓存。

### 取舍建议
- 大部分业务：用「先 DB → 再删缓存」足够。
- 高并发热点场景：结合版本号/锁/事件驱动，保证缓存更强一致性。

最后非常感谢大家的关注和支持，有任何问题都可以在评论区提出，我一定会认真解答！
