# 今日面试之快问快答：Redis篇
<img width="1032" height="726" alt="image" src="https://github.com/user-attachments/assets/39efa197-470b-4bc2-a5ed-903126ec5dd4" />

## 1. Redis 支持事务吗？
Redis 是支持“事务”的，但和数据库中的事务存在差异。
Redis 事务通过 `MULTI`、`EXEC`、`DISCARD`、`WATCH` 这些命令实现。
在 `MULTI` 和 `EXEC` 之间输入的命令仅处于“排队”状态，直到执行 `EXEC` 时才会一次性顺序执行。

## 2. Redis 的事务能回滚吗？
严格来说，Redis 事务不能像数据库那样进行回滚：
- 若事务中某个命令存在语法错误（如拼写错误），Redis 在 `EXEC` 时会发现，且整个事务不会执行；
- 若为运行时错误（如对 string 类型执行 list 操作），Redis 仅在该命令执行时报错，前面的命令依然会执行，后面的命令也会继续执行，不会回滚。
这意味着 Redis 的事务是原子性地执行命令队列，而非保证所有命令都成功才提交。

## 3. 为什么 Redis 不支持事务回滚？
这与 Redis 的设计理念相关：
- 简单性优先：Redis 核心目标是高性能和简单模型，无需像数据库那样维护复杂的回滚日志；
- 数据操作幂等性：Redis 鼓励开发者在设计时保证操作幂等，或通过 `WATCH` 乐观锁机制进行控制；
- 性能考虑：事务回滚需要额外的存储和计算成本，为保持快速执行，Redis 选择放弃传统回滚机制。

## 4. 开发中如何应对？
常见解决办法：
- 使用 `WATCH` 实现乐观锁：监控关键 key，若事务执行前 key 被修改，则放弃事务；
- 保证命令幂等：确保重复执行不会产生错误状态；
- Lua 脚本：将多条命令写入一段 Lua 脚本，Redis 会保证脚本原子执行。

## 结论（一句话）
Redis 不支持传统意义上的事务回滚（undo/rollback）：`MULTI/EXEC` 不会在执行过程中自动回滚已经生效的命令；只有在“队列阶段”检测到错误时才可能拒绝并丢弃整个队列（以及 `WATCH` 能在冲突时中止事务）。

## 核心机制（需了解的行为差别）
### MULTI / EXEC 的工作流
`MULTI` 之后命令被排队（服务器回复 `QUEUED`），直到 `EXEC` 才真正执行。`EXEC` 会按顺序逐条执行这些命令，并返回每条命令的结果数组。

### 两种错误时机（影响执行/回滚）
- 队列阶段发现错误（queue-time）：如语法/参数错误，发命令时会立即报错且不将该命令入队；从 Redis 2.6.5 起，若积累命令时检测到错误，`EXEC` 会拒绝执行并丢弃队列；
- 执行阶段失败（exec-time）：例如对 string 做 list 操作，执行时会返回 `WRONGTYPE` 错误；但其他已排队并成功执行的命令不会回滚，`EXEC` 会把每条命令的结果（包括错误）返回给客户端。

### WATCH（乐观锁）的作用
`WATCH` 会监视 key：若在 `WATCH` 后到 `EXEC` 前这些 key 被他人修改，`EXEC` 会返回 `null`（事务被中止）。这是一种乐观并发控制，能避免并发冲突导致部分执行。注意这并非“回滚”，而是“冲突时不执行任何入队命令”。

### Lua 脚本（EVAL）——更接近“原子性”的替代（有重要注意事项）
Lua 脚本执行期间会阻塞其他客户端，保证隔离（其他客户端不会看到脚本执行期间的中间状态），这是 Redis 文档所称的脚本“原子执行”的含义。
但不可将这种“隔离”误认为传统数据库那种带回滚的原子性——若脚本在中间抛错，之前已执行的写入不会被自动回滚（社区有相关讨论/示例）。即脚本可保证“他人不会看到部分执行的中间态”，但脚本内部若发生运行时错误，可能会留下部分更改。
（额外复杂性：脚本的复制/持久化有不同模式，与 AOF/复制方式的选择有关，出错/崩溃下的恢复语义有细节，官方文档有说明。）

## 为什么 Redis 不做 rollback（设计理由）
- 简单与性能优先：维护 undo 日志、回滚机制会显著增加复杂度和开销，与 Redis 作为内存、高性能数据结构服务器的设计目标冲突；
- 鼓励应用层解决：Redis 提供 `WATCH`、Lua 脚本、原子命令（如 `INCR`、`SETNX`）来满足大多数并发/原子性需求；复杂的事务语义通常建议交给关系型数据库或在应用层实现补偿逻辑。

## 实践建议（针对 Java 后端开发者）
1. 需“全或无”且必须严格回滚→使用关系型数据库或支持事务回滚的存储，Redis 不适合作为需要完整 ACID 回滚保证的主存储；
2. 大多数多命令原子需求→使用 Lua 脚本（EVAL），把逻辑放在服务器端一次运行（注意错误处理与超时/性能）。若脚本内部可能抛错且无法接受部分写入，需在脚本中自行实现补偿/回滚逻辑（记录旧值并在出错时恢复），或在脚本里事前校验所有前置条件，尽量避免中途出错；
3. 并发冲突场景→使用 WATCH + MULTI（乐观重试），流程为：读取—计算—`MULTI`—排队写—`EXEC`，若 `EXEC` 返回 null 则重试；
4. 设计为幂等 + 补偿：在业务层尽量让操作幂等，或设计可补偿操作（补偿事务），即便发生部分写入也能安全恢复。
